#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.01
#define MIN_DIST 0.0

float planeDistance(vec3 p){
    return p.y;
}

float createSphere(vec4 center, float radius, vec3 p){
    float sphereDistance = length(p - center.xyz) - radius;
    
    return sphereDistance;
}

float createCylinder(vec3 position, vec2 height){
    vec2 d = abs(vec2(length(position.xz), position.y)) - height;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

float createCone( in vec3 position, in vec2 center, float height )
{
    vec2 q = height*vec2(center.x,-center.y)/center.y;
    vec2 w = vec2( length(position.xz), position.y );
    
	vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );
    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );
    float k = sign( q.y );
    float d = min(dot( a, a ),dot(b, b));
    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );
	return sqrt(d)*sign(s);
}

float renderScene(vec3 position, out vec4 color){
    float wheel = createSphere(vec4(-1.5, 0.5, 6.0, 1.0), 0.5, position);
    float wheelTwo = createSphere(vec4(1.5, 0.5, 6.0, 1.0), 0.5, position);
    //float cone = createCone(vec3( 0.1, 0.1, 0.1), vec2(0.1, 0.1), 0.9);
    //float cylinder = createCylinder(position - vec3(1.0, 0.25, -2.0), vec2(0.15, 0.25));
    float d = min(wheel, wheelTwo);
    float planeDistance = planeDistance(position);
    d = min(d, planeDistance);
    //d = min(d, cone);
    color = vec4(0.0);
    if(d == wheel){
        color = vec4(1.0, 0.0, 0.0, 1.0);
    }
    else if(d == planeDistance){
        color = vec4(1.0);
    }
    return d;
}

/*
float rayMarch(vec3 rayOrigin, vec3 rayDirection) {
    float distanceOrigin = 0.0;
    
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = rayOrigin + rayDirection*distanceOrigin;
        float ds = renderScene(p);
        distanceOrigin += ds;
        if(distanceOrigin > MAX_DIST || ds < SURF_DIST) break;
    }
    
    return distanceOrigin;
}
*/

float shortestDistanceToSurface(out vec4 color, vec3 eye, vec3 marchingDirection, float start, float end) {
    float depth = start;
    for (int i = 0; i < MAX_STEPS; i++) {
        float dist = renderScene(eye + depth * marchingDirection, color);
        if (dist < SURF_DIST) {
			return depth;
        }
        depth += dist;
        if (depth >= end) {
            return end;
        }
    }
    return end;
}

/*
vec3 getNormal(vec3 p){
    float d = renderScene(p);
    vec2 e = vec2(0.01, 0.0);
    
    vec3 n = d - vec3(
    renderScene(p - e.xyy),
    renderScene(p - e.yxy),
    renderScene(p - e.yyx));
    
    return normalize(n);
}
*/

/*
float getLight(vec3 p) {
    vec3 lightPos = vec3(0.0, 5.0, 6.0);
    //lightPos.xz += vec2(sin(iTime), cos(iTime)*2.0);
    vec3 light = normalize(lightPos - p);
    vec3 n = getNormal(p);
    
    float diff = clamp(dot(n, light), 0.0, 1.0);
    float d = rayMarch(p + n*SURF_DIST*2.0, light);
    //if(d < length(lightPos - p)) diff *= 0.1;
    if (d > MAX_DIST){  
    	return diff;
    }
    return 1.0;
}
*/