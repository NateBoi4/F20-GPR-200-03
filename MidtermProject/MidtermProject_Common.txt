// Work by Demetrius Nekos and Nathan Boisvert
// This common tab is responsible for holding all functions and structs relevent to the overall project
// This tab also contains the code for the main implementations of lighting, ray marching, and scene rendering
// 

#define MAX_STEPS 150
#define MAX_DIST 150.0
#define SURF_DIST 0.0001
#define MIN_DIST 0.0
  
// sColoredOBJ: Object in scene
//    color: color of object
//    dist:  distance of object calculated by corresponding distance function (initOBJ)  
struct sColoredObj
{
    vec4 color;
    float dist;
};
        
// OBJintersect: Returns the intesection of two volumes
//    distA: the first volume
//    distA: the second volume
sColoredObj OBJintersect(sColoredObj distA, sColoredObj distB) 
{
    if (distA.dist > distB.dist)
        return distA;
    return distB;
}

// OBJintersect: Returns the union of two volumes
//    distA: the first volume
//    distA: the second volume
sColoredObj OBJunion(in sColoredObj distA, in sColoredObj distB) 
{
    if (distA.dist > distB.dist)
        return distB;
    return distA;

}

// OBJintersect: Returns the difference of two volumes
//    distA: the first volume
//    distA: the second volume, which will be removed
sColoredObj OBJdifference(in sColoredObj distA, in sColoredObj distB) 
{
    //return (distA.dist > -distB.dist) ? distA : distB; //WHY TF DOESNT ISNT THIS LEGAL
    if (distA.dist > -1.0 * distB.dist)
        return distA;
    distB.dist = -1.0 * distB.dist;
    return distB;
}

// initSphere: distance to a given sphere
//    center: Coordinates to manipulate spheres position in coordinate space. Sets center point of sphere
//    radius: Holds the radius of the spheres
//    p:      Coordinate in space that a ray hits a sphere created by this function
//    color:  Holds the color of the sphere
// Functions main purpose is to algebraically calculate the distance of any point on the sphere
// from a position passed into the function and return that distance.
sColoredObj initSphere(vec4 center, float radius, 
                      vec4 color, vec3 p)
{
    sColoredObj sphere;
    sphere.color = color;
    sphere.dist = length(p - center.xyz) - radius;
    return sphere;
}

// initPlane: distance to the plane y = 0
// p: sample point 
// color: color of plane (used as grid in this instance)
// Grid design inspired from theraot on shadertoy
// https://www.shadertoy.com/view/wljXRh
sColoredObj initPlane(vec4 color, vec3 p)
{
	sColoredObj plane;
    vec2 tile_coord = p.xz;
	float size = 1.0;  // size of the tile
	float edge = size/16.0; // size of the edge
    float tile_brightness = 0.1; // 0.9 controls the brighness of the face of the tile
    float edge_brightness = 2.0; // 0.5 controls the darkness of the edge
	tile_coord = (mod(tile_coord, size) - mod(tile_coord - edge, size) - edge) * 1.0/size; //Calculates grid
	plane.color = vec4(tile_brightness + length(tile_coord) * edge_brightness);
    plane.dist = p.y;
    return plane;
}

// initCylinder: Distance function of a cylinder borrowed from: 
// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm
//    position: Coordinate in space that a ray hits a cylinder created by this function
//    top:      Holds the coordinate space for the top part of the cylinder (axis alignment)
//    bottom:   Holds the coordinate space for the bottom part of the cylinder (axis alignment)
//    center:   Coordinates to manipulate cylinders position in coordinate space. Sets center point of cylinder
//    radius:   Holds the radius of the cylinder
//    color:    Holds the color of the cylinder
// Functions main purpose is to algebraically calculate the distance of any point on the cylinder
// from a position passed into the function and return that distance.
sColoredObj initCylinder(vec3 position, vec3 top, vec3 bottom, vec4 center,
                          float radius, vec4 color)
{
	sColoredObj cylinder;
	cylinder.color = color;
    vec3  bottomToTop = bottom - top;
    vec3  positionToTop = (position - center.xyz) - top;
    float fullLength = dot(bottomToTop, bottomToTop);
    float currentLength = dot(positionToTop, bottomToTop);
    float x = length(positionToTop * fullLength - bottomToTop * currentLength) - radius * fullLength;
    float y = abs(currentLength - fullLength * 0.5) - fullLength * 0.5;
    float x2 = x * x;
    float y2 = y * y * fullLength;
    
    float d = (max(x, y) < 0.0) ? -min(x2, y2) : (((x > 0.0) ? x2 : 0.0) + ((y > 0.0) ? y2 : 0.0));
    
    cylinder.dist = sign(d) * sqrt(abs(d)) / fullLength;
	return cylinder;
}

// initCone: Distance function of a cone borrowed from: 
// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm
//    position:     Coordinate in space that a ray hits a cone created by this function
//    top:          Holds the coordinate space for the top part of the cone (axis alignment)
//    bottom:       Holds the coordinate space for the botom part of the cone (axis alignment)
//    center:       Coordinates to manipulate cones position in coordinate space. Sets center point of cone
//    topRadius:    Radius of the top part of the cone
//    bottomRadius: Radius of the bottom part of the cone
//    color:        Holds the color of the cone
// Functions main purpose is to algebraically calculate the distance of any point on the cone
// from a position passed into the function and return that distance.
sColoredObj initCone(vec3 position, vec3 top, vec3 bottom, vec4 center, float topRadius,
				float bottomRadius, vec4 color)
{
	sColoredObj cone;
	cone.color = color;
    float middleRadius  = bottomRadius - topRadius;
    float bottomFromTop = dot(bottom - top, bottom - top);
    float positionFromTop = dot((position - center.xyz) - top, (position - center.xyz) - top);
    float positionIntersect = dot((position - center.xyz) - top, bottom - top) / bottomFromTop;

    float x = sqrt( positionFromTop - positionIntersect * positionIntersect * bottomFromTop );

    float topx = max(0.0, x - ((positionIntersect < 0.5) ? topRadius : bottomRadius));
    float topy = abs(positionIntersect - 0.5) - 0.5;

    float k = middleRadius * middleRadius + bottomFromTop;
    float f = clamp( (middleRadius * (x - topRadius) + positionIntersect * bottomFromTop) / k, 0.0, 1.0 );

    float bottomx = x - topRadius - f * middleRadius;
    float bottomy = positionIntersect - f;
    
    float s = (bottomx < 0.0 && topy < 0.0) ? -1.0 : 1.0;
    
    cone.dist = s * sqrt( min(topx * topx + topy * topy * bottomFromTop,
                       bottomx * bottomx + bottomy * bottomy * bottomFromTop) );
	return cone;
}

// initBox: Distance function of a box borrowed from: 
// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm
//    position:   Coordinate in space that a ray hits a box created by this function
//    dimensions: Holds the dimensions of the box
//    center:     Coordinates to manipulate boxes position in coordinate space. Sets center point of box
//    color:      Holds the color of the box
// Functions main purpose is to algebraically calculate the distance of any point on the box
// from a position passed into the function and return that distance.
sColoredObj initBox( vec3 position, vec3 dimensions, vec4 center, vec4 color)
{
	sColoredObj box;
	box.color = color;
    
	vec3 q = abs(position - center.xyz) - dimensions;
	box.dist = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
	return box;
}

// initTorus: Distance function of a torus borrowed from: 
// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm
//    position: Coordinate in space that a ray hits a torus created by this function
//    toroid:   axis of revolution against which the torus is drawn to. Usually represented as a circle
//    center:   Coordinates to manipulate tori position in coordinate space. Sets center point of torus
//    color:    Holds the color of the torus
// Functions main purpose is to algebraically calculate the distance of any point on the torus
// from a position passed into the function and return that distance.
sColoredObj initTorus( vec3 position, vec2 toroid, vec4 center, vec4 color)
{
    sColoredObj torus;
    torus.color = color;
    
    vec2 innerDistance = vec2(length((position.xy - center.xy)) - toroid.x,(position.z - center.z));
    torus.dist = length(innerDistance) - toroid.y;
    return torus;
}

// initCapsule: Distance function of a capsule borrowed from: 
// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm
//    position: Coordinate in space that a ray hits a capsule created by this function
//    top:      Holds the coordinate space for the top part of the capsule (axis alignment)
//    bottom:   Holds the coordinate space for the bottom part of the capsule (axis alignment)
//    center:   Coordinates to manipulate capsules position in coordinate space. Sets center point of capsule
//    radius:   Holds the radius of the capsule
//    color:    Holds the color of the capsule
// Functions main purpose is to algebraically calculate the distance of any point on the capsule
// from a position passed into the function and return that distance.
sColoredObj initCapsule( vec3 position, vec3 top, vec3 bottom, vec4 center, 
                float radius, vec4 color)
{
    sColoredObj capsule;
    capsule.color = color;
    
    vec3 topFromPosition = (position - center.xyz) - top, topFromBottom = bottom - top;
    float height = clamp( dot(topFromPosition, topFromBottom)
                         / dot(topFromBottom, topFromBottom), 0.0, 1.0 );
    capsule.dist = length( topFromPosition - topFromBottom * height ) - radius;
    return capsule;
}
   
// renderScene: Creates objects according to their distance functions
//              Adds model to scene by returning the calculated sum distance of all objects
//    Position: A ray created using ray marching
//    Color:    Output color
// Sets up scene for model rendering by creating containers for Objects and using distance functions
// to fill containers with data for each object being rendered in scene. Also uses union, difference,
// and intersection functions to determine if space is being displayed, negated, or conjoined 
// Model reference: https://sketchfab.com/3d-models/classic-tron-lightcycle-a9eae73385234105b548b0e35a3e63a4
sColoredObj renderScene(vec3 position)
{

    // use Logic to build the correct distance

    // front wheel done
    sColoredObj d = OBJdifference(initSphere(vec4(-1.5, 1.0, 6.0, 1.0), 1.0, // Front wheel
                  vec4(1.0, 0.5, 0.0, 1.0), position),
                  initSphere(vec4(-1.5, 1.0, 5.1, 1.0), 0.8, // Front wheel negative space left
                  vec4(1.0, 0.5, 0.0, 1.0), position));
    d = OBJdifference(d,initSphere(vec4(-1.5, 1.0, 6.9, 1.0), 0.8, // Front wheel negative space right
                  vec4(1.0, 0.5, 0.0, 1.0), position));
    d = OBJunion(d, initSphere(vec4(-1.5, 1.0, 6.4, 1.0), 0.15, // Front wheel cap left
                  vec4(1.0), position));
    d = OBJunion(d, initSphere(vec4(-1.5, 1.0, 5.6, 0.0), 0.15, // Frot wheel cap right
                  vec4(1.0), position));
    d = OBJunion(d, initCylinder(position, vec3(0.0, 0.0, 0.4), vec3(0.0, 0.0, -0.4), vec4(-1.5, 1.0, 6.0, 1.0),
                  0.9, vec4(0.0))); // Front wheel black
    
    // grey chasis
    d = OBJunion(d, initBox(position, vec3(1.5, 0.65, 0.3), vec4(0.0, 1.0, 6.0, 1.0),
                  vec4(0.7))); // body
    d = OBJunion(d, initCylinder(position, vec3(0.0, 0.0, 0.4), vec3(0.0, 0.0, -0.4), vec4(1.4, 0.65, 6.0, 1.0),
                  0.06, vec4(1.0, 0.5, 0.0, 1.0))); // foothold axel thing
    d = OBJunion(d, initCone(position, vec3(0.0,0.0,0.0), vec3(1.4,0.0,0.0), vec4(-.7, 1.0, 6.0, 1.0),
                  0.6, 0.2, vec4(0.7))); // Front wheel cone
    d = OBJunion(d, initCone(position, vec3(0.0,-0.1,0.0), vec3(-.5,0.0,0.0), vec4(0.95, 0.87, 5.8, 1.0),
                  0.2, 0.1, vec4(0.7))); // Left pipe bit
    d = OBJunion(d, initCone(position, vec3(0.0,-0.1,0.0), vec3(-.5,0.0,0.0), vec4(0.95, 0.87, 6.2, 1.0),
                  0.2, 0.1, vec4(0.7))); // right pipe bit);
	d = OBJunion(d, initBox(position, vec3(1.0, 0.65, 0.02), vec4(1.7, 1.0, 5.72, 1.0),
                  vec4(0.7))); // backwheel frame left
    d = OBJunion(d, initBox(position, vec3(1.0, 0.65, 0.02), vec4(1.6, 1.0, 6.28, 1.0),
                  vec4(0.7))); // backwheel frame right
    d = OBJunion(d, initCylinder(position, vec3(0.5,0.3,0.0), vec3(-1.2,-0.5,0.0), vec4(2.2, 1.6, 6.0, 1.0),
                  0.30, vec4(0.7))); // Back Wheel body cover);
    d = OBJunion(d, initCone(position, vec3(0.0,0.0,-0.08), vec3(-.65,-0.15,0.0), vec4(2.65,1.7, 5.8, 1.0),
                  0.2, 0.1, vec4(0.7))); // Left exhaust
    d = OBJunion(d, initCone(position, vec3(0.0,0.0,0.08), vec3(-.65,-0.15,0.0), vec4(2.65,1.7, 6.2, 1.0),
                  0.2, 0.1, vec4(0.7))); // right exhaust

    
    d = OBJdifference(d, initCylinder(position, vec3(0.55,0.3,0.0), vec3(-1.25,-0.5,0.0), vec4(2.2, 1.6, 6.0, 1.0),
                  0.27, vec4(0.7))); //Back Wheel body cover negative
    d = OBJdifference(d, initCylinder(position, vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -1.0), vec4(2.6, 1.0, 6.0, 1.0),
                  0.28, vec4(0.7))); //back wheel 'axis' negative
    d = OBJdifference(d,initBox(position, vec3(0.5, 1.5, 0.5), vec4(3.1, 1.0, 6.0, 1.0),
                  vec4(0.7))); // backwheel cutoff negative
    d = OBJdifference(d, initBox(position, vec3(0.7, 0.8, 0.25), vec4(2.8, 1.0, 6.0, 1.0),
                  vec4(0.7))); // backwheel cutoff negative


    //orange body
    sColoredObj top = OBJunion(initCylinder(position, vec3(0.0,0.0,0.2), vec3(0.0,0.0,-0.2), vec4(0.1, -3.6, 6.0, 1.0),
                  6.0, vec4(1.0, 0.5, 0.0, 1.0)), // Top piece
                  initCylinder(position, vec3(0.0,0.0,0.39), vec3(0.0,0.0,-0.39), vec4(0.1, -3.66, 6.0, 1.0),
                  6.0, vec4(1.0, 0.5, 0.0, 1.0))); // Top main bit);
    top = OBJintersect(top, initBox(position, vec3(2.3, 1.0, 0.9), vec4(0.0, 1.74, 6.0, 1.0),
                  vec4(1.0, 0.5, 0.0, 1.0))); // Orange body base cuttoff negative
    top = OBJdifference(top,initCone(position, vec3(0.0,0.0,0.0), vec3(1.6,0.0,0.0), vec4(-.78, 1.0, 6.0, 1.0),
                  0.7, 0.2, vec4(1.0, 0.5, 0.0, 1.0))); // orage top front slant negative
    top = OBJdifference(top,initBox(position, vec3(0.7, 0.5, 0.9), vec4(-1.76, 1.33, 6.0, 1.0),
                  vec4(1.0, 0.5, 0.0, 1.0))); // orange body wheel negative
	top = OBJdifference(top,initBox(position, vec3(0.7, 0.5, 0.9), vec4(0.4, 0.6, 6.0, 1.0),
                  vec4(1.0, 0.5, 0.0, 1.0)));
    top = OBJdifference(top,initCone(position, vec3(0.0,0.0,0.0), vec3(0.3,-0.7,0.0), vec4(0.48, 0.83, 6.0, 1.0),
                  0.8, 0.8, vec4(1.0, 0.5, 0.0, 1.0))); // orage top front slant negative
	top = OBJdifference(top,initBox(position, vec3(0.5, 0.8, 0.9), vec4(2.0, 0.6, 6.0, 1.0),
                  vec4(1.0, 0.5, 0.0, 1.0)));
    top = OBJdifference(top,initCylinder(position, vec3(0.5,0.5,0.0), vec3(-0.8,-0.2,0.0), vec4(2.44, 1.36, 5.4, 1.0),
                  0.35, vec4(1.0, 0.5, 0.0, 1.0))); // orange body Back Wheel cover negative left
    top = OBJdifference(top,initCylinder(position, vec3(0.5,0.5,0.0), vec3(-0.8,-0.2,0.0), vec4(2.44, 1.36, 6.6, 1.0),
                  0.35, vec4(1.0, 0.5, 0.0, 1.0))); // orange body Back Wheel cover negative right

    
    // windows
    sColoredObj windows = OBJunion(initSphere(vec4(2.6, 1.0, 6.0,0.0), 0.15, // back wheel cap
                  vec4(1.0), position), 
                  initCapsule(position, vec3(0.5, 0.0, 0.0), vec3(-0.5, 0.0, 0.0), vec4(-0.4, 1.8, 5.45, 1.0), 
                  0.3, vec4(0.0))); // right window
    windows = OBJunion(windows, initCapsule(position, vec3(0.5, 0.0, 0.0), vec3(-0.5, 0.0, 0.0), vec4(-0.47, 1.8, 6.45, 1.0), 
                0.3, vec4(0.0))); //left window
    windows = OBJdifference(windows, initBox(position, vec3(1.3, 0.8, 1.25), vec4(-0.4, 0.99, 5.55, 1.0),
                  vec4(0))); // Window lower cutoff
    windows = OBJdifference(windows, initBox(position, vec3(1.3, 0.8, 1.25), vec4(1.2, 1.5, 5.55, 1.0),
                  vec4(0))); // Window back cutoff
    windows = OBJdifference(windows, initCone(position, vec3(0.0,0.0,0.0), vec3(1.2,0.0,0.0), vec4(-1.3, 2.4, 5.45, 1.0),
                  0.6, 0.3, vec4(0.0))); // window left slant negative
    windows = OBJdifference(windows, initCone(position, vec3(0.0,0.0,0.0), vec3(1.2,0.0,0.0), vec4(-1.3, 2.4, 6.45, 1.0),
                  0.6, 0.3, vec4(0.0))); // window right slant negative
	
    // trail
    sColoredObj trail = OBJdifference( initBox(position, vec3(500.0, 0.8, 0.1), vec4(502.6, 1.0, 6.0, 1.0),
                  vec4(mix(vec4(1.0),vec4(1.0, 0.5, 0.0, 1.0),position.y / 0.8))), // trail
    initCylinder(position, vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -1.0), vec4(2.6, 1.0, 6.0, 1.0),
                  0.8, vec4(0.0)));
    d = OBJunion(d, trail);


    // back wheel
    sColoredObj wheel = OBJdifference(initTorus(position, vec2(0.8,0.19), vec4(2.6, 1.0, 6.0, 1.0), vec4(1.0, 0.5, 0.0, 1.0)),
                  initCylinder(position, vec3(0.0, 0.0, 0.4), vec3(0.0, 0.0, -0.4), vec4(2.6, 1.0, 6.0, 1.0),
                  0.7, vec4(1.0, 0.5, 0.0, 1.0))); // Back Wheel Negative Space
    wheel = OBJunion(wheel, initCylinder(position, vec3(0.0, 0.0, 0.02), vec3(0.0, 0.0, -0.02), vec4(2.6, 1.0, 6.0, 1.0),
                  0.7, vec4(0.0))); // Back Wheel black
    d = OBJunion(d, initSphere(vec4(2.6, 1.0, 6.0,0.0), 0.15, // back wheel cap
                  vec4(1.0), position));
                       
    //combining subobjects
    d = OBJunion(d, wheel);
    d = OBJunion(d, top);
	d = OBJunion(d, windows);
    d = OBJunion(d, initPlane(vec4(1.0),position));
        
    return d;
}

// RayMarching Function: Draws scene by getting a distance for every object in the scene from the 
//                       Calculated position found from ray origin and ray direction
//    color:             Output color
//    eye:               ray origin
//    marchingDirection: ray direction
//    start:             Minimum distance ray can travel while searching for Objects
//    end:               Maximum distance ray can travel while searching for Objects
sColoredObj shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {
    //credit to https://www.shadertoy.com/view/4tcGDr
    sColoredObj dist;
    float depth = start;
    for (int i = 0; i < MAX_STEPS; i++) {
        dist = renderScene(eye + depth * marchingDirection);
        if (dist.dist < SURF_DIST) {
            dist.dist = depth;
			return dist;
        }
        depth += dist.dist;
        if (depth >= end) {
            dist.dist = end;
			return dist;
        }
    }
    dist.dist = end;
	return dist;
}

// getNormal: Calculate normal for given rat
//    p: A ray created using ray marching
// "ShaderToy Tutorial - Ray Marching for Dummies!" 
// by Martijn Steinrucken aka BigWings/CountFrolic - 2018
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

// This shader is part of a tutorial on YouTube
// https://youtu.be/PGtv-dBi2wE
// https://www.shadertoy.com/view/XlGBW3
vec3 getNormal(vec3 p)
{  
    float d = renderScene(p).dist;
    vec2 e = vec2(0.01, 0.0);
    
    vec3 n = d - vec3(
    renderScene(p - e.xyy).dist,
    renderScene(p - e.yxy).dist,
    renderScene(p - e.yyx).dist);
    
    return normalize(n);
}

// calcLighting: calculates Lambertian and Blinn-Phong reflectance, and returns part of the summation of the final color
//    light: the current Point Light
//    position:     point on the sphere that we are drawing
//    normal:       normal vector from point
//    rayOrigin:    input ray origin
//	  viewVector:	vector from point to camera
vec4 calcLighting (in vec3 lightpos, in vec4 lightcolor, float lightintense, in vec3 position,
                   in vec3 normal, in vec3 rayOrigin, in vec3 viewVector, in vec4 Objectcolor)
{
    //Taken from Demetri's Lab 4
    // LAMBERTIAN REFLECTANCE
    vec3 lightVector = lightpos.xyz - position; // get vector of position to the light
	float lightLength = length(lightVector); // get length of light vector
    lightVector = lightVector / lightLength; // normalizes vector
   
    float diffuseCoefficient = max(0.0, dot(lightVector, normal)); // get coefficient
   
    float intensityRatio = lightLength/lightintense; // simplifying attenuation equation by doing this once
    float attenuation = 1.0 / (1.0 + intensityRatio +
                             (intensityRatio * intensityRatio)); // get attenuation
    float Lambertian = diffuseCoefficient * attenuation; // final lambertian

    // BLINN-PHONG REFLECTANCE
   
    float specular = max(0.0,dot(normal, normalize(viewVector + lightVector))); // get base specular coefficient
    specular *= specular; // specularCoefficient^2
    specular *= specular; // specularCoefficient^4
    specular *= specular * specular * specular; // ^16
    specular *= specular * specular * specular; // ^64

    specular *= 4.0; // Blinn coefficient
   
    //return (Lambertian * vec4(normal * 0.5 + 0.5, 1.0) + specular) * lightcolor;
    return (Lambertian * Objectcolor + specular) * lightcolor;
}