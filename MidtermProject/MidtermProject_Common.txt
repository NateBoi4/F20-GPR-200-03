#define MAX_STEPS 150
#define MAX_DIST 150.0
#define SURF_DIST 0.0001
#define MIN_DIST 0.0

struct sSphere
{
    float radius;
    vec4 center;
};
    
struct sCone
{
    float topRadius;
    float bottomRadius;
    vec3 top;
    vec3 bottom;
    vec4 center;
};

struct sCylinder
{
	float radius;
	vec3 top;
	vec3 bottom;
    vec4 center;
};

struct sBox
{
	vec3 dimensions;
    vec4 center;
};
    
struct sColoredObj
{
    vec4 color;
    int index;
    float dist;
};
        
struct sSphereObj
{
	sColoredObj Obj;
    sSphere sphere;
};

struct sConeObj
{
	sColoredObj Obj;
	sCone cone;
};

struct sCylinderObj
{
	sColoredObj Obj;
	sCylinder cylinder;
};

struct sBoxObj
{
    sColoredObj Obj;
	sBox box;
};

struct sPlaneObj
{
    sColoredObj Obj;
};

// OBJintersect: Returns the intesection of two volumes
//    distA: the first volume
//    distA: the second volume
sColoredObj OBJintersect(sColoredObj distA, sColoredObj distB) 
{
    //return max(distA, distB);
    if (distA.dist > distB.dist)
        return distA;
    return distB;
}

// OBJintersect: Returns the union of two volumes
//    distA: the first volume
//    distA: the second volume
sColoredObj OBJunion(in sColoredObj distA, in sColoredObj distB) 
{
    //return min(distA, distB);
    if (distA.dist > distB.dist)
        return distB;
    return distA;

}

// OBJintersect: Returns the difference of two volumes
//    distA: the first volume
//    distA: the second volume, which will be removed
sColoredObj OBJdifference(in sColoredObj distA, in sColoredObj distB) 
{
    //return (distA.dist > -distB.dist) ? distA : distB; //WHY TF DOESNT ISNT THIS LEGAL
    if (distA.dist > -1.0 * distB.dist)
        return distA;
    distB.dist = -1.0 * distB.dist;
    return distB;
}

// createSphere: distance to a given sphere
//    center: centerpoint of sphere
//    radius: radius of sphere
//    p:      sample point
sSphereObj initSphere(vec4 center, float radius, 
                      vec4 color, int index, vec3 p)
{
    sSphereObj sphere;
    sphere.sphere.center = center;
    sphere.sphere.radius = radius;
    sphere.Obj.color = color;
    sphere.Obj.index = index;
    sphere.Obj.dist = length(p - center.xyz) - radius;
    return sphere;
}

// planeDistance: distance to the plane y = 0
//    p: sample point 
sPlaneObj initPlane(vec4 color, vec3 p)
{
	sPlaneObj plane;
    plane.Obj.color = color;
    plane.Obj.index = 0;
    plane.Obj.dist = p.y;
    return plane;
}

sCylinderObj initCylinder(vec3 position, vec3 top, vec3 bottom, float radius,
							vec4 color, int index)
{
	sCylinderObj cylinder;
	cylinder.cylinder.top = top;
	cylinder.cylinder.bottom = bottom;
	cylinder.cylinder.radius = radius;
	cylinder.Obj.color = color;
	cylinder.Obj.index = index;
    vec3  bottomToTop = bottom - top;
    vec3  positionToTop = position - top;
    float fullLength = dot(bottomToTop,bottomToTop);
    float currentLength = dot(positionToTop,bottomToTop);
    float x = length(positionToTop*fullLength-bottomToTop*currentLength) - radius*fullLength;
    float y = abs(currentLength-fullLength*0.5)-fullLength*0.5;
    float x2 = x*x;
    float y2 = y*y*fullLength;
    
    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));
    
    cylinder.Obj.dist = sign(d)*sqrt(abs(d))/fullLength;
	return cylinder;
}

<<<<<<< HEAD
float createCylinder(vec3 position, vec2 height){
    vec2 d = abs(vec2(length(position.xz), position.y)) - height;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

float createCone( in vec3 position, in vec2 center, float height )
{
    vec2 q = height*vec2(center.x,-center.y)/center.y;
    vec2 w = vec2( length(position.xz), position.y );
    
	vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );
    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );
    float k = sign( q.y );
    float d = min(dot( a, a ),dot(b, b));
    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );
	return sqrt(d)*sign(s);
}

float renderScene(vec3 position, out vec4 color){
    float wheel = createSphere(vec4(-1.5, 0.5, 6.0, 1.0), 0.5, position);
    float wheelTwo = createSphere(vec4(1.5, 0.5, 6.0, 1.0), 0.5, position);
    //float cone = createCone(vec3( 0.1, 0.1, 0.1), vec2(0.1, 0.1), 0.9);
    //float cylinder = createCylinder(position - vec3(1.0, 0.25, -2.0), vec2(0.15, 0.25));
    float d = min(wheel, wheelTwo);
    float planeDistance = planeDistance(position);
    d = min(d, planeDistance);
    //d = min(d, cone);
    color = vec4(0.0);
    if(d == wheel){
        color = vec4(1.0, 0.0, 0.0, 1.0);
    }
    else if(d == planeDistance){
        color = vec4(1.0);
    }
    return d;
=======
sConeObj initCone(vec3 position, vec3 top, vec3 bottom, vec4 center, float topRadius,
				float bottomRadius, vec4 color, int index)
{
	sConeObj cone;
	cone.cone.top = top;
	cone.cone.bottom = bottom;
    cone.cone.center = center;
	cone.cone.topRadius = topRadius;
	cone.cone.bottomRadius = bottomRadius;
	cone.Obj.color = color;
	cone.Obj.index = index;
    float middleRadius  = bottomRadius - topRadius;
    float bottomFromTop = dot(bottom - top, bottom - top);
    float positionFromTop = dot((position - center.xyz) - top, (position - center.xyz) - top);
    float positionIntersect = dot((position - center.xyz) - top, bottom - top) / bottomFromTop;

    float x = sqrt( positionFromTop - positionIntersect * positionIntersect * bottomFromTop );

    float topx = max(0.0, x - ((positionIntersect < 0.5) ? topRadius : bottomRadius));
    float topy = abs(positionIntersect - 0.5) - 0.5;

    float k = middleRadius * middleRadius + bottomFromTop;
    float f = clamp( (middleRadius * (x - topRadius) + positionIntersect * bottomFromTop) / k, 0.0, 1.0 );

    float bottomx = x - topRadius - f * middleRadius;
    float bottomy = positionIntersect - f;
    
    float s = (bottomx < 0.0 && topy < 0.0) ? -1.0 : 1.0;
    
    cone.Obj.dist = s * sqrt( min(topx * topx + topy * topy * bottomFromTop,
                       bottomx * bottomx + bottomy * bottomy * bottomFromTop) );
	return cone;
>>>>>>> testing
}

sBoxObj initBox( vec3 position, vec3 dimensions, vec4 center, vec4 color, int index )
{
	sBoxObj box;
	box.box.dimensions = dimensions;
    box.box.center = center;
	box.Obj.color = color;
	box.Obj.index = index;
	vec3 q = abs(position - center.xyz) - dimensions;
	box.Obj.dist = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
	return box;
}
    
float renderScene(vec3 position, out vec4 color)
{
    sSphereObj Spheres[3];
    sBoxObj Boxes[3];
    sConeObj Cones[3];
    int currentarray, currentindex;
    
    // create scene objects
    Spheres[0] = initSphere(vec4(-1.5, 0.0, 6.0, 1.0), 1.0, 
                  vec4(1.0, 0.0, 0.0, 1.0), 0, position);
    Spheres[1] = initSphere(vec4(-1.0, 0.5, 5.5, 1.0),0.5,
             vec4(1.0, 1.0, 0.0, 1.0), 1, position);
    Spheres[2] = initSphere(vec4(1.5, 0.0, 6.0, 1.0), 1.0,
    				vec4(1.0, 0.0, 1.0, 1.0),2,position);
    Boxes[0] = initBox(position, vec3(0.7, 2.5, 0.6), vec4(0.0, 0.5, 6.5, 1.0),
                       vec4(1.0, 1.0, 0.0, 1.0), 0);
    Cones[0] = initCone(position, vec3(0.0,0.0,0.0), vec3(0.0,1.0,-0.1), vec4(0.0, 3.0, 6.6, 1.0),
                        0.7, 0.1, vec4(0.0, 0.5, 0.5, 1.0), 0);
    sPlaneObj planeDistance = initPlane(vec4(1.0),position);

    // use Logic to build the correct distance
    sColoredObj d = OBJdifference(Spheres[0].Obj, Spheres[1].Obj);
    d = OBJunion(d, Boxes[0].Obj);
    d = OBJunion(d, Cones[0].Obj);
    d = OBJunion(d, Spheres[2].Obj);
    d = OBJunion(d, planeDistance.Obj);
    
    //assign color
	color = d.color;
    
    return d.dist;
}

float shortestDistanceToSurface(out vec4 color, vec3 eye, vec3 marchingDirection, float start, float end) {
    //credit to https://www.shadertoy.com/view/4tcGDr
    
    float depth = start;
    for (int i = 0; i < MAX_STEPS; i++) {
        float dist = renderScene(eye + depth * marchingDirection, color);
        if (dist < SURF_DIST) {
			return depth;
        }
        depth += dist;
        if (depth >= end) {
            return end;
        }
    }
    return end;
}


vec3 getNormal(vec3 p){
    
    vec4 color;//placeholder, not needed for this.
    
    
    float d = renderScene(p,color);
    vec2 e = vec2(0.01, 0.0);
    
    vec3 n = d - vec3(
    renderScene(p - e.xyy,color),
    renderScene(p - e.yxy,color),
    renderScene(p - e.yyx,color));
    
    return normalize(n);
}

// calcLighting: calculates Lambertian and Blinn-Phong reflectance, and returns part of the summation of the final color
//    light: the current Point Light
//    position:     point on the sphere that we are drawing
//    normal:       normal vector from point
//    rayOrigin:    input ray origin
//	  viewVector:	vector from point to camera
vec4 calcLighting (in vec3 lightpos, in vec4 lightcolor, float lightintense, in vec3 position,
                   in vec3 normal, in vec3 rayOrigin, in vec3 viewVector, in vec4 Objectcolor)
{
    //Taken from Demetri's Lab 4
    // LAMBERTIAN REFLECTANCE
    vec3 lightVector = lightpos.xyz - position; // get vector of position to the light
	float lightLength = length(lightVector); // get length of light vector
    lightVector = lightVector / lightLength; // normalizes vector
   
    float diffuseCoefficient = max(0.0, dot(lightVector, normal)); // get coefficient
   
    float intensityRatio = lightLength/lightintense; // simplifying attenuation equation by doing this once
    float attenuation = 1.0 / (1.0 + intensityRatio +
                             (intensityRatio * intensityRatio)); // get attenuation
    float Lambertian = diffuseCoefficient * attenuation; // final lambertian

    // BLINN-PHONG REFLECTANCE
   
    float specular = max(0.0,dot(normal, normalize(viewVector + lightVector))); // get base specular coefficient
    specular *= specular; // specularCoefficient^2
    specular *= specular; // specularCoefficient^4
    specular *= specular * specular * specular; // ^16
    specular *= specular * specular * specular; // ^64
    specular *= specular * specular * specular; // ^256 = a
    specular *= 4.0; // Blinn coefficient
   
    //return (Lambertian * vec4(normal * 0.5 + 0.5, 1.0) + specular) * lightcolor;
    return (Lambertian * Objectcolor + specular) * lightcolor;

}